// Copyright (c) 2015 The Sippet Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <bitset>

#include "g729a.h"

extern "C" {
#include "ld8a.h"
#include "g729a_encoder.h"
}

#include "testing/gtest/include/gtest/gtest.h"

namespace {

template<typename T>
void PrintWord(const T *v, size_t size, const size_t columns,
               std::ostream &out) {
  size_t i;
  for (i = 0; i < size; i++) {
    if (i > 0)
      out << " ";
    out << std::setfill('0')
        << std::setw(sizeof(T) * 2)
        << std::hex
        << (int)v[i];
  }
  if (size < columns) { // Complete with spaces
    size_t j, k;
    for (j = i; j < columns; j++) {
      out << " ";
      for (k = 0; k < sizeof(T) * 2; k++)
        out << " ";
    }
  }
}

// A predicate-formatter for asserting that two arrays are the same
template<typename T>
::testing::AssertionResult AssertSameArrays(const char* m_expr,
                                            const char* n_expr,
                                            const char* size_expr,
                                            const T *m,
                                            const T *n,
                                            size_t size) {
  const size_t columns = 4;
  std::ostringstream out;
  const T *a = reinterpret_cast<const T*>(m);
  const T *b = reinterpret_cast<const T*>(n);
  size_t i, errors = 0;
  for (i = 0; i < size; i += columns) {
    size_t len = columns;
    if (i + len > size)
      len = size - i;
    out << "  ";
    PrintWord(a + i, len, columns, out);
    if (memcmp(a + i, b + i, len * sizeof(T)) == 0) {
      out << "   ";
    }
    else {
      out << " ! ";
      ++errors;
    }
    PrintWord(b + i, len, columns, out);
    out << "\n";
  }
  if (!errors)
    return ::testing::AssertionSuccess();
  return ::testing::AssertionFailure()
      << m_expr << " and " << n_expr << " differ:\n"
      << out.str();
}

}  // empty namespace

class G729Test : public testing::Test {
 public:
  void SetUp() override {
  }
 protected:
  static const UWord8 expected_bits_[2][10];
  static const Word16 expected_parm_[2][PRM_SIZE];

  static const UWord16 pcm_speech_input_[4][L_FRAME];
  static const UWord8 bitstream_output_[4][10];
};

const UWord8 G729Test::expected_bits_[2][10] = {
  { 0x1a, 0xc1, 0x00, 0xa0, 0x00, 0xfa, 0xc2, 0xff, 0xfd, 0x50 },
  { 0xe0, 0xA2, 0xD4, 0x21, 0x41, 0x69, 0x59, 0xEF, 0x20, 0x50 },
};

const Word16 G729Test::expected_parm_[2][PRM_SIZE] = {
  { 0x001a, 0x0304, 0x0002, 0x0001, 0x0000, 0x000f,
    0x0056, 0x0002, 0x1fff, 0x000a, 0x0050 },
  { 0x00e0, 0x028b, 0x0050, 0x0001, 0x0141, 0x0006,
    0x004a, 0x0019, 0x1de4, 0x0000, 0x0050 },
};

const UWord16 G729Test::pcm_speech_input_[4][L_FRAME] = {
  { 0xfeff, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0a00, 0x0500,
    0x0200, 0x0a00, 0x0a00, 0x0700, 0x0800, 0x0c00, 0x0000, 0x0000,
    0x0400, 0x0300, 0x0200, 0x0600, 0x0a00, 0x0400, 0x0900, 0x0500,
    0x0300, 0xfcff, 0x0400, 0x0000, 0xfcff, 0x0300, 0xf7ff, 0xfbff,
    0x0100, 0x0600, 0x0100, 0xfdff, 0x0300, 0x0100, 0x0000, 0x0b00,
    0x0300, 0x0000, 0x0000, 0x0200, 0x0900, 0xfaff, 0x0200, 0x0c00,
    0x0000, 0x0100, 0x0300, 0x0600, 0x0700, 0xfbff, 0x0000, 0xfeff,
    0x0000, 0x0900, 0x0400, 0x0000, 0xfaff, 0xffff, 0x0b00, 0x0100,
    0x0000, 0x0400, 0x0000, 0x0000, 0xfbff, 0xfdff, 0x0000, 0xfeff,
    0xffff, 0x0000, 0xf7ff, 0x0100, 0x0300, 0x0000, 0xffff, 0xfeff },
  { 0x0100, 0xf7ff, 0xf5ff, 0x0000, 0xf6ff, 0xf0ff, 0xfdff, 0xfdff,
    0xf6ff, 0xf8ff, 0xfeff, 0xffff, 0x0000, 0xfcff, 0xf7ff, 0xf4ff,
    0xfdff, 0xfcff, 0xf9ff, 0xf9ff, 0xf5ff, 0xf3ff, 0xf0ff, 0xf6ff,
    0xe7ff, 0xeeff, 0xf5ff, 0xe9ff, 0xf4ff, 0xe4ff, 0xe3ff, 0xecff,
    0xefff, 0xe4ff, 0xe0ff, 0xefff, 0xf1ff, 0xe5ff, 0xecff, 0xf1ff,
    0xf4ff, 0xf4ff, 0xf0ff, 0xf3ff, 0xf5ff, 0xf6ff, 0xedff, 0xf8ff,
    0xf7ff, 0xebff, 0xf2ff, 0xf2ff, 0xe9ff, 0xe3ff, 0xddff, 0xdcff,
    0xeeff, 0xedff, 0xe3ff, 0xf5ff, 0xf4ff, 0xf4ff, 0xebff, 0xf3ff,
    0xedff, 0xecff, 0xefff, 0xebff, 0xeaff, 0xe6ff, 0xeaff, 0xf2ff,
    0xd9ff, 0xe7ff, 0xebff, 0xe8ff, 0xe9ff, 0xd6ff, 0xedff, 0xdaff },
  { 0xd7ff, 0xe5ff, 0xe4ff, 0xdaff, 0xddff, 0xe6ff, 0xdbff, 0xe5ff,
    0xe9ff, 0xe1ff, 0xefff, 0xdfff, 0xdbff, 0xeaff, 0xe6ff, 0xddff,
    0xd9ff, 0xdfff, 0xd7ff, 0xdeff, 0xe7ff, 0xe7ff, 0xe0ff, 0xdaff,
    0xe8ff, 0xd9ff, 0xe3ff, 0xe7ff, 0xe4ff, 0xe2ff, 0xdeff, 0xdfff,
    0xe2ff, 0xd8ff, 0xdaff, 0xdfff, 0xdcff, 0xe7ff, 0xe4ff, 0xe3ff,
    0xdfff, 0xdfff, 0xeaff, 0xdcff, 0xe6ff, 0xe8ff, 0xe4ff, 0xdeff,
    0xdaff, 0xecff, 0xe1ff, 0xd1ff, 0xecff, 0xe8ff, 0xd7ff, 0xeaff,
    0xefff, 0xe1ff, 0xebff, 0xe3ff, 0xfaff, 0xddff, 0xf2ff, 0xf4ff,
    0xddff, 0xf1ff, 0xedff, 0xe5ff, 0xf3ff, 0xe9ff, 0xf2ff, 0xe9ff,
    0xe5ff, 0xffff, 0xeeff, 0xf6ff, 0xf0ff, 0xe8ff, 0xf5ff, 0xf3ff },
  { 0xedff, 0xeaff, 0xe1ff, 0xf2ff, 0xf4ff, 0xeaff, 0xfcff, 0xf4ff,
    0xedff, 0xf7ff, 0xf8ff, 0xf8ff, 0x0000, 0x0400, 0x0100, 0xf6ff,
    0x0e00, 0x0100, 0x0000, 0x1500, 0x0300, 0xfcff, 0xfeff, 0x0f00,
    0x1300, 0xfaff, 0x0f00, 0x1500, 0x1100, 0x1100, 0x0f00, 0x1000,
    0x1200, 0x2300, 0x0900, 0x1100, 0x2900, 0x2600, 0x0f00, 0x0c00,
    0x2200, 0x0d00, 0x1000, 0x2800, 0x1000, 0x1800, 0x1900, 0x2400,
    0x2100, 0x1600, 0x1900, 0x2800, 0x1400, 0x0600, 0x2100, 0x1300,
    0x1600, 0x0f00, 0x1d00, 0x2400, 0x1e00, 0x2500, 0x1c00, 0x2c00,
    0x2000, 0x1900, 0x2c00, 0x2e00, 0x2200, 0x1900, 0x2000, 0x2c00,
    0x3300, 0x2700, 0x2e00, 0x2000, 0x2100, 0x3b00, 0x2200, 0x1600 }
};

const UWord8 G729Test::bitstream_output_[4][10] = {
  { 0xb0, 0x95, 0x0b, 0xc0, 0x00, 0xfa, 0xcb, 0xa2, 0x73, 0x2c },
  { 0x7a, 0xae, 0x2e, 0x75, 0x01, 0x4f, 0xa3, 0xe8, 0x34, 0x0d },
  { 0xc0, 0xe3, 0xf9, 0x29, 0x80, 0x3f, 0xa6, 0xe4, 0x04, 0x01 },
  { 0x58, 0xc8, 0x2b, 0xbc, 0x93, 0xd4, 0x15, 0x40, 0x04, 0x69 },
};

TEST_F(G729Test, Bits2Prm) {
  Word16 output_parm[PRM_SIZE];

  for (int i = 0; i < sizeof(expected_bits_)/sizeof(expected_bits_[0]); i++) {
    bits2prm_ld8k(expected_bits_[i], output_parm);

    EXPECT_PRED_FORMAT3(AssertSameArrays,
      expected_parm_[i], output_parm, PRM_SIZE);
  }
}

TEST_F(G729Test, Prm2Bits) {
  UWord8 output_bits[10];
  
  for (int i = 0; i < sizeof(expected_bits_) / sizeof(expected_bits_[0]); i++) {
    prm2bits_ld8k(expected_parm_[i], output_bits);

    EXPECT_PRED_FORMAT3(AssertSameArrays, expected_bits_[i], output_bits,
      10);
  }
}

TEST_F(G729Test, Encoder) {
  Word16 prm[PRM_SIZE];
  UWord8 bitstream[10];
  g729a_encode_frame_state state;

  Init_Pre_Process(&state.preProcessState);
  Init_Coder_ld8a(&state.encoderState);

  for (size_t i = 0; i < sizeof(pcm_speech_input_) / sizeof(pcm_speech_input_[0]); i++) {
    const Word16 *pcm = (Word16 *)pcm_speech_input_[i];
    Pre_Process(&state.preProcessState, pcm,
                state.encoderState.new_speech, L_FRAME);
    Coder_ld8a(&state.encoderState, prm);
    prm2bits_ld8k(prm, bitstream);

    EXPECT_PRED_FORMAT3(AssertSameArrays, bitstream_output_[i], bitstream,
      10);
  }
}
